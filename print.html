<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shakti Rust Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Hardware.html"><strong aria-hidden="true">1.1.</strong> Hardware</a></li><li class="chapter-item expanded "><a href="no-std.html"><strong aria-hidden="true">1.2.</strong> no-std</a></li><li class="chapter-item expanded "><a href="whyrust.html"><strong aria-hidden="true">1.3.</strong> Why Rust in Shakti?</a></li><li class="chapter-item expanded "><a href="tooling.html"><strong aria-hidden="true">1.4.</strong> tooling</a></li><li class="chapter-item expanded "><a href="Installation.html"><strong aria-hidden="true">1.5.</strong> Installation</a></li></ol></li><li class="chapter-item expanded "><a href="peripherals/peripherals.html"><strong aria-hidden="true">2.</strong> Peripherals</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="peripherals/gpio.html"><strong aria-hidden="true">2.1.</strong> GPIO</a></li><li class="chapter-item expanded "><a href="peripherals/uart.html"><strong aria-hidden="true">2.2.</strong> UART</a></li><li class="chapter-item expanded "><a href="peripherals/spi.html"><strong aria-hidden="true">2.3.</strong> SPI</a></li><li class="chapter-item expanded "><a href="peripherals/i2c.html"><strong aria-hidden="true">2.4.</strong> I2C</a></li><li class="chapter-item expanded "><a href="peripherals/pwm.html"><strong aria-hidden="true">2.5.</strong> PWM</a></li></ol></li><li class="chapter-item expanded "><a href="examples/examples.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/gpio_appls.html"><strong aria-hidden="true">3.1.</strong> GPIO Applications</a></li><li class="chapter-item expanded "><a href="examples/uart_appls.html"><strong aria-hidden="true">3.2.</strong> UART Applications</a></li><li class="chapter-item expanded "><a href="examples/spi_appls.html"><strong aria-hidden="true">3.3.</strong> SPI Applications</a></li></ol></li><li class="chapter-item expanded "><a href="Contributors.html"><strong aria-hidden="true">4.</strong> Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Shakti Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="shakti-rust-book"><a class="header" href="#shakti-rust-book">Shakti Rust Book</a></h1>
<p>by <a href="https://github.com/yashwanthsinghm" title="yashwanthsinghm"><strong><code>Yashwanth Singh M</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></p>
<p>The Shakti processor is an open-source initiative started by <strong>IIT Madras</strong> to produce production-grade processors, complete System on Chips (SoCs), development boards, and a SHAKTI-based software platform. This documentation will provide a Rust SDK using the Shakti <strong>RISC-V</strong> hardware abstraction layer to run secure and memory-safe code on the Shakti family of chips.</p>
<h1 id="introduction-shakti"><a class="header" href="#introduction-shakti">Introduction Shakti</a></h1>
<p>Introducing the SHAKTI processor, a groundbreaking development in RISC-V architecture by the RISE lab at <strong>IIT Madras</strong>. With a visionary roadmap for diverse market segments, SHAKTI unveils its initial offerings—the E and C-classes. Tailored for IoT, Embedded Systems, and Desktop markets, these processors feature royalty-free and open-source attributes under the BSD3 license.</p>
<p>The E-class, a 32-bit microprocessor, operates seamlessly with versatile RISC-V ISA support. Sporting an in-order 3-stage pipeline and operating at a frequency of under 200MHz on silicon, it competes against ARM's M-class (Cortex-M series) cores. Positioned for applications in low-power computing environments, automotive systems, and IoT, the E-class is capable of running Real-Time Operating Systems (RTOS) like Zephyr OS and FreeRTOS. Explore PINAKA (E32-A35) and PARASHU (E32-A100) in the E-class, designed for smart-cards, motor controls, and home automation.</p>
<p>On the other hand, the C-class, an in-order 6-stage 64-bit microcontroller, supports the entire RISC-V ISA. Targeting mid-range compute systems with a variable frequency range of 200-800MHz, it is customizable for both low-power and high-performance variants, positioning it against ARM's Cortex A35/A55. Operating systems such as Linux, SEL4, and FreeRTOS have been successfully ported and verified with the C-class. Explore VAJRA (C64-A100) in the C-class, a single-chip 64-bit microcontroller aimed at mid-range application workloads in industrial controllers and the Desktop market.</p>
<h1 id="rust-in-shakti-processor"><a class="header" href="#rust-in-shakti-processor">Rust in Shakti Processor</a></h1>
<p>Enhancing the capabilities of these processors is the SHAKTI RISC-V HAL, an open-source hardware abstraction layer written in Rust, known as <a href="https://github.com/yashwanthsinghm/shakti_riscv_hal"><strong>Shakti_riscv_hal</strong></a>. This HAL provides abstraction for all peripherals available in the E-class and C-class, including Vajra, Pinaka, and Parasu, making them more powerful, memory-safe, and leveraging the advantages of the Rust programming language. Rust, renowned for its focus on memory safety and zero-cost abstractions, significantly enhances the security of embedded programming, ensuring robust and reliable applications for SHAKTI processors. As SHAKTI continues to revolutionize applications in low-power, high-performance, and mid-range workloads, these processors, coupled with Rust's secure programming capabilities, pave the way for a new era of computing possibilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arty-a7---artix7-100t-fpga"><a class="header" href="#arty-a7---artix7-100t-fpga">Arty A7 - Artix7 100T FPGA</a></h1>
<p><img src="https://digilent.com/reference/_media/reference/programmable-logic/arty/arty-2.png" alt="Arty A7" /></p>
<p>The Arty A7, formerly known as the Arty, is a ready-to-use development platform designed around the Artix-7™ Field Programmable Gate Array (FPGA) from Xilinx. It was designed specifically for use as a MicroBlaze Soft Processing System. When used in this context, the Arty A7 becomes the most flexible processing platform you could hope to add to your collection, capable of adapting to whatever your project requires. Unlike other Single Board Computers, the Arty A7 isn't bound to a single set of processing peripherals: One moment it's a communication powerhouse chock-full of UARTs, SPIs, IICs, and an Ethernet MAC, and the next it's a meticulous timekeeper with a dozen 32-bit timers.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<h3 id="xilinx-artix-7-fpga"><a class="header" href="#xilinx-artix-7-fpga">Xilinx Artix-7 FPGA</a></h3>
<ul>
<li>5,200 slices containing four 6-input LUTs and 8 flip-flops (15,850 slices)1)</li>
<li>1,800 Kbits of fast block RAM (4,860 Kbits)2)</li>
<li>5 clock management tiles (CMTs), each with a phase-locked loop and mixed-mode clock manager (6 CMTs)3)</li>
<li>90 DSP slices (240 DSP slices)4)</li>
<li>Internal clock speeds exceeding 450MHz</li>
<li>On-chip analog-to-digital converter (XADC)</li>
<li>Programmable over JTAG and Quad-SPI Flash</li>
</ul>
<h3 id="system-features"><a class="header" href="#system-features">System Features</a></h3>
<ul>
<li>256MB DDR3L with a 16-bit bus @ 333MHz</li>
<li>16MB Quad-SPI Flash</li>
<li>USB-JTAG Programming circuitry</li>
<li>Powered from USB or any 7V-15V source</li>
</ul>
<h3 id="system-connectivity"><a class="header" href="#system-connectivity">System Connectivity</a></h3>
<ul>
<li>10/100 Mbps Ethernet</li>
</ul>
<ul>
<li>USB-UART Bridge</li>
</ul>
<h3 id="interaction-and-sensory-devices"><a class="header" href="#interaction-and-sensory-devices">Interaction and Sensory Devices</a></h3>
<ul>
<li>4 Switches</li>
<li>4 Buttons</li>
<li>1 Reset Button</li>
<li>4 LEDs</li>
<li>4 RGB LEDs</li>
<li>Expansion Connectors</li>
<li>4 Pmod connectors</li>
<li>Arduino/ChipKit Shield connector</li>
</ul>
<h3 id="referneces"><a class="header" href="#referneces">Referneces</a></h3>
<ul>
<li><a href="https://digilent.com/reference/programmable-logic/arty-a7/reference-manual">Arty 7 Reference Manual</a></li>
<li><a href="https://digilent.com/reference/programmable-logic/arty-a7/start">Arty 7 resources</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="no_std"><a class="header" href="#no_std">no_std</a></h3>
<p>The application of #![no_std] at the crate level in Rust denotes a deliberate choice to link with the core crate rather than the std crate. This choice is significant in scenarios where the program aims for minimal dependencies and operates in environments without a full-fledged standard library. In this context, the <a href="https://doc.rust-lang.org/core/">libcore</a> crate serves as a versatile foundation, offering a platform-agnostic subset of the standard library.</p>
<p>Libcore focuses on essential language constructs like floats, strings, and slices, providing crucial APIs for these primitives. Additionally, it exposes interfaces for low-level processor features, including atomic operations and SIMD instructions. However, it deliberately omits APIs related to platform-specific integrations, ensuring its adaptability to diverse environments.</p>
<p>It's worth noting that due to these characteristics, code marked as no_std and utilizing <a href="https://doc.rust-lang.org/core/">libcore</a> finds applications beyond standard Rust environments. Yet, it is essential to recognize that such code is not suitable for tasks requiring direct interaction with specific platform features, making it unsuitable for bootstrapping activities such as building bootloaders, firmware, or kernels. This intentional abstraction provides a flexible foundation for projects that prioritize efficiency, minimalism, and portability.</p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<div class="table-wrapper"><table><thead><tr><th>feature</th><th>no_std</th><th>std</th></tr></thead><tbody>
<tr><td>heap (dynamic memory)</td><td>*</td><td>✓</td></tr>
<tr><td>collections (Vec, BTreeMap, etc)</td><td>**</td><td>✓</td></tr>
<tr><td>stack overflow protection</td><td>✘</td><td>✓</td></tr>
<tr><td>runs init code before main</td><td>✘</td><td>✓</td></tr>
<tr><td>libstd available</td><td>✘</td><td>✓</td></tr>
<tr><td>libcore available</td><td>✓</td><td>✓</td></tr>
<tr><td>writing firmware, kernel, or bootloader code</td><td>✓</td><td>✘</td></tr>
</tbody></table>
</div>
<p>* Only if you use the <code>alloc</code> crate and use a suitable allocator like [alloc-cortex-m].</p>
<p>** Only if you use the <code>collections</code> crate and configure a global default allocator.</p>
<p>** HashMap and HashSet are not available due to a lack of a secure random number generator.</p>
<h2 id="bare-metal-environments"><a class="header" href="#bare-metal-environments">Bare Metal Environments</a></h2>
<p>In the realm of bare metal programming, your program begins its execution without any pre-loaded code. Unlike environments supported by an operating system, a bare metal setup lacks the infrastructure to load the standard library. Here, the program, along with the crates it utilizes, solely interacts with the hardware—running in a "bare metal" state.</p>
<p>To instruct Rust not to load the standard library, the no_std attribute is employed. In this context, the platform-agnostic elements of the standard library are accessible through libcore. Notably, <a href="https://doc.rust-lang.org/core/">libcore</a> deliberately excludes components that may not be universally suitable in an embedded environment. A prime example is the omission of a memory allocator for dynamic memory allocation.</p>
<p>In scenarios where additional functionalities, such as a memory allocator, are needed, numerous crates are available to fulfill these requirements. These crates extend the capabilities of bare metal programming by providing specific features while maintaining compatibility with the constraints of embedded systems.</p>
<p>Rust, with its emphasis on memory safety and low-level control, emerges as a valuable tool for bare metal programming. Its no_std feature, coupled with libcore, enables developers to harness the power of Rust in environments where direct hardware interaction is paramount, allowing for efficient, secure, and tailored solutions in the realm of embedded systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-rust-in-shakti-"><a class="header" href="#why-rust-in-shakti-">Why Rust in Shakti ?</a></h1>
<p>Using Rust in the SHAKTI processor brings several advantages, aligning with Rust's strengths in system programming and embedded development. Here are key reasons for considering Rust in the context of the SHAKTI processor:</p>
<p><strong>Memory Safety</strong> : Rust's ownership system and borrowing rules ensure memory safety without sacrificing performance. This is crucial in embedded systems where memory management is often critical for stability and security. Rust helps prevent common programming errors like null pointer dereferences and buffer overflows, leading to more robust and reliable code.</p>
<p><strong>Zero-Cost Abstractions</strong> : Rust allows developers to write high-level, expressive code without incurring a runtime overhead. This is essential for embedded systems where resource constraints are common. The zero-cost abstractions provided by Rust enable efficient code execution without sacrificing readability or expressiveness.</p>
<p><strong>Concurrency and Parallelism</strong> : Rust provides powerful abstractions for concurrent and parallel programming, making it well-suited for modern processors with multiple cores. This can enhance the performance of applications running on the SHAKTI processor, especially in scenarios where parallel processing is beneficial.</p>
<p><strong>Static Typing</strong> : Rust's static typing system helps catch many common errors at compile time, reducing the likelihood of runtime failures. This is advantageous in embedded systems where debugging and maintenance can be challenging.</p>
<p><strong>Community and Ecosystem</strong> : Rust has a vibrant and growing community with a focus on systems programming and embedded development. The availability of libraries, tools, and documentation makes it easier for developers working on the SHAKTI processor to find support and resources.</p>
<p><strong>Cross-Platform Development</strong> : Rust supports cross-compilation, enabling developers to write code on one platform and deploy it on the SHAKTI processor or other architectures. This flexibility is beneficial for cross-platform development and porting code to different embedded systems.</p>
<p><strong>Open Source and Transparency</strong> : Rust is an open-source language with a transparent development process. This aligns well with the principles of the SHAKTI project, which emphasizes openness and collaboration. The open nature of Rust fosters community involvement and innovation.</p>
<p>In summary, Rust's focus on safety, performance, and expressiveness, along with its strong community support, makes it a compelling choice for programming the SHAKTI processor, particularly in embedded and system-level development.</p>
<h2 id="why-not-c-"><a class="header" href="#why-not-c-">why not c ?</a></h2>
<p>C is a powerful and established language in embedded systems, but Rust provides a modern and safer alternative tailored for system-level programming challenges. The decision between Rust and C hinges on project requirements, developer preferences, and the goals of the embedded system. Rust's features, such as enhanced memory safety and zero-cost abstractions, make it particularly appealing for modern processors like SHAKTI, striking a balance between performance and safety.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="gdb-gnu-debugger"><a class="header" href="#gdb-gnu-debugger">GDB (GNU Debugger)</a></h3>
<p>GDB is a powerful debugger commonly used in embedded development. It allows developers to inspect and debug programs running on embedded systems. GDB supports various architectures, including ARM, making it suitable for debugging ARM Cortex-M microcontrollers.</p>
<p>Installation Steps for GDB on Linux:</p>
<p>open terminal</p>
<ul>
<li><code>sudo apt-get install gdb        </code></li>
<li><code>gdb --version </code></li>
</ul>
<h3 id="openocd-open-on-chip-debugger"><a class="header" href="#openocd-open-on-chip-debugger">OpenOCD (Open On-Chip Debugger)</a></h3>
<p>OpenOCD acts as a bridge between GDB and the debugging hardware, such as ST-Link, on your embedded system. It facilitates communication by translating GDB's TCP/IP-based remote debug protocol to the specific protocol used by the debugging hardware.</p>
<p>Installation Steps for GDB and OpenOCD on Linux:</p>
<ul>
<li><code>sudo apt-get install openocd        </code></li>
<li><code>openocd --version </code></li>
</ul>
<h3 id="rustup-and-nightly"><a class="header" href="#rustup-and-nightly">Rustup and Nightly</a></h3>
<p><strong>Install Rustup</strong>:</p>
<ul>
<li><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
<li><code>source $HOME/.cargo/env</code></li>
</ul>
<p><strong>Install Nightly</strong>:</p>
<p>After installing Rustup, you can install the nightly toolchain:</p>
<p><code>rustup toolchain install nightly</code>
<code>rustup default nightly</code></p>
<p><strong>Add riscv target supported for Shakti</strong></p>
<ul>
<li><code>rustup target add thumbv7em-none-eabihf</code></li>
<li><code>rustup show</code></li>
</ul>
<p><strong>Note : rustup show will show all the installed tool chains and targets, which helps to verify.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing--seting-up-fpga"><a class="header" href="#installing--seting-up-fpga">Installing &amp; seting up FPGA</a></h1>
<h2 id="installing-vivado"><a class="header" href="#installing-vivado">Installing Vivado</a></h2>
<ol>
<li>
<p>If you dont have a Xilinx account, create a free account, using url below:</p>
<ul>
<li><a href="https://login.amd.com/app/amd_accountamdcom_1/exk559qg7f4aW4yim697/sso/saml?SAMLRequest=fVLRTsIwFP2Vpe%2Bsc2ywNYxkQowkqARQE19I6Tpo7NrR2yn8vWWg4oM89eb23HNuz%2BkAaCVrkjd2q%2BZ813Cw3r6SCkh7kaHGKKIpCCCKVhyIZWSRP0xJ6AekNtpqpiXycgBurNBqpBU0FTcLbj4E48%2FzaYa21tZAMKaM6UZZn1aFz3SFjwoYauxoSiE5rjVYBwLkjd0aQtEj4e%2B41BuhfoZpXWNXr86krnTd1Q3m%2B%2Fc4TnebfhnR1%2Bggql7axwC6VUPeZJyhVVwmtEzLtBf3aa9MWDdas7DXLfpxkhRJUTBWsCh1YICGTxRYqmyGwiCMOkHYCdJlkJIwIHHiB0H4hrw7bRhvLcxQSSVw5M3O1twKVQi1ue7j%2BgQCcr9czjqzp8USeS%2FcQPt8B0DDwXF70u5jLvK5Tku%2FQ0HD%2FyJw57k1wBcSJ72aPDrOyXimpWAHL5dSf44Mp5ZnyJqGIzw8Tf39P8Mv&amp;RelayState=https%3A%2F%2Faccount%2Eamd%2Ecom%2Fen%2Fprofile%2Ehtml">login to Xilinx</a></li>
</ul>
</li>
<li>
<p>Download the AMD Unified Installer for FPGAs &amp; Adaptive SoCs 2023.2: Linux Self Extracting Web Installer from below link:</p>
<ul>
<li><a href="https://www.xilinx.com/support/download.html">vivado</a></li>
</ul>
</li>
<li>
<p>Make the Vivado installer executable and run it using:</p>
<ul>
<li><code>chmod +x Xilinx_*.bin</code></li>
<li><code>sudo ./Xilinx_*.bin</code></li>
</ul>
</li>
<li>
<p>Once the installer loads2</p>
</li>
</ol>
<ul>
<li><code>click "Next"</code></li>
</ul>
<ol start="5">
<li>Now enter your Xilinx username and password. Then Click "Next".</li>
<li>Agree to all three statements and Click "Next". Incase, you disagree you can’t
proceed further.</li>
<li>Select "Vivado HL WebPACK or Vivado Lab " and click "Next".</li>
<li>Click "Reset to Defaults" and then press "Next". 3</li>
<li>By default, the "installation directory" is "/tools/Xilinx". This is the default installation
directory. Click "Next".</li>
<li>Click "Install" and wait for the installer to finish.</li>
<li>Install the Xilinx cable drivers:</li>
</ol>
<ul>
<li><code>cd /tools/Xilinx/Vivado/2018.3/data/xicom/cable_drivers/lin64/install_script/install_drivers</code></li>
<li><code>sudo ./install_drivers</code></li>
</ul>
<ol start="12">
<li>Do some permissions cleanup:
<ul>
<li><code>cd</code></li>
<li><code>cd .Xilinx/Vivado</code></li>
<li><code>sudo chown -R $USER *</code></li>
<li><code>sudo chmod -R 777 *</code></li>
<li><code>sudo chgrp -R $USER *</code></li>
</ul>
</li>
<li>Add Vivado path to the environmental variable PATH in .bashrc :
<ul>
<li><code>export PATH=$PATH:/tools/Xilinx/Vivado/2018.3/bin</code></li>
<li><code>export PATH=$PATH:/tools/Xilinx/SDK/2018.3/bin  </code></li>
</ul>
</li>
<li>Test Vivado</li>
</ol>
<ul>
<li><code>vivado -version</code></li>
</ul>
<h2 id="programming-arty-7-fpga"><a class="header" href="#programming-arty-7-fpga">Programming Arty-7 FPGA</a></h2>
<p>Refer <a href="https://shakti.org.in/docs/shakti-soc-user-manual.pdf">shakti user manual</a> to program the board.</p>
<div style="break-before: page; page-break-before: always;"></div><p><strong>SHAKTI</strong>, a groundbreaking RISC-V-based processor, introduces the E and C-classes—representing the initial set of indigenous designs tailored for the Internet of Things (IoT), Embedded Systems, and Desktop markets. Emphasizing an open and collaborative approach, the processor design is devoid of royalties and released under the BSD3 license. SHAKTI's E and C-classes provide a foundation for innovative processor architectures with diverse applications.</p>
<h2 id="e-class"><a class="header" href="#e-class">E-Class</a></h2>
<p>The 32-bit E-Class microprocessor is designed for low-power compute environments, automotive, and IoT applications. Operating on an in-order 3-stage pipeline below 200MHz, it supports all RISC-V ISA extensions. Noteworthy for running Real-Time Operating Systems (RTOS) like Zephyr OS and FreeRTOS, the E-Class competes with ARM's M-class cores. Key applications include smart cards, motor controls, and home automation.</p>
<p><strong>PINAKA (E32-A35)</strong>:
PINAKA, built around the E-Class, is a 32-bit microcontroller with 4KB ROM and 128KB BRAM. Featuring 32 GPIO pins (8 for onboard LEDs and switches), it includes a Platform Level Interrupt Controller (PLIC), Timer (CLINT), 2 SPI, 3 UART, 2 I2C, 6 PWM, Xilinx ADC, Soft Float library, Physical Memory Protection (PMP), an onboard FTDI-based debugger, and Pin Mux support with Arduino-compatible assignments.</p>
<p><strong>PARASHU (E32-A100)</strong>:
Sharing the E-Class configuration, PARASHU is a 32-bit microcontroller with 4KB ROM and 256MB DDR. Suited for various applications, it provides additional memory capacity.</p>
<h2 id="c-class"><a class="header" href="#c-class">C-Class</a></h2>
<p>The 64-bit C-Class, a 6-stage microcontroller, supports the entire RISC-V ISA. Customizable for 200-800MHz mid-range compute systems, it competes with ARM's Cortex A35/A55. Compatible with Linux, SEL4, and FreeRTOS, the C-Class caters to both low-power and high-performance variants.</p>
<p><strong>VAJRA (C64-A100)</strong>:
VAJRA, built around the C-Class, is a single-chip 64-bit microcontroller with 4KB ROM and 256MB DDR3 RAM. Targeted at mid-range applications like industrial controllers and the desktop market, VAJRA shares a configuration with PARASHU.</p>
<h2 id="peripherals"><a class="header" href="#peripherals">Peripherals</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Peripherals</th><th>info</th></tr></thead><tbody>
<tr><td>GPIO Pins</td><td>32</td></tr>
<tr><td>Upper</td><td>8 pins Onboard LEDs and switches</td></tr>
<tr><td>PLIC</td><td>1</td></tr>
<tr><td>Counter</td><td>1</td></tr>
<tr><td>SPI</td><td>2</td></tr>
<tr><td>UART</td><td>3</td></tr>
<tr><td>I2C</td><td>2</td></tr>
<tr><td>PWM</td><td>6</td></tr>
<tr><td>ADC</td><td>Xilinx</td></tr>
<tr><td>CLINT</td><td>1</td></tr>
<tr><td>Float</td><td>Soft library</td></tr>
<tr><td>PMP</td><td>Enabled</td></tr>
<tr><td>Debugger</td><td>Onboard FTDI based</td></tr>
<tr><td>Pin Mux</td><td>Yes</td></tr>
<tr><td>Ethernet lite</td><td>PARASHU, VAJRA</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="gpio"><a class="header" href="#gpio">GPIO</a></h1>
<p>The GPIO functionality in the SHAKTI processor is a versatile feature, enabling the generation of custom waveforms, activation of signals, and handling interrupts. Here are additional details about the GPIO operation:</p>
<h2 id="gpio-registers"><a class="header" href="#gpio-registers">GPIO Registers</a></h2>
<ul>
<li>
<p><strong>GPIO DIRECTION Register</strong>:
The GPIO DIRECTION register configures the GPIO pin as either an input or output. This register plays a crucial role in determining the operational mode of the GPIO pins.</p>
</li>
<li>
<p><strong>GPIO DATA Register</strong>:
The GPIO DATA register holds the input data from GPIO or the output data to GPIO. It is accessible in 1-byte, 2-byte, and 4-byte sizes, providing flexibility in data manipulation.</p>
</li>
<li>
<p><strong>Interrupt Handling (GPIO Pins 0 - 7)</strong>:
GPIO pins 0 - 7 can accept external events as interrupts. To use a GPIO pin as an interrupt source, the respective GPIO pin(s) must be configured as inputs. This feature enhances the processor's ability to respond to external stimuli.</p>
</li>
</ul>
<p><strong>GPIO Registers</strong>:</p>
<ul>
<li>
<p><strong>GPIO_DIRECTION_CNTRL_REG (Offset 'h00)</strong>:
This 32-bit register controls the direction of GPIO pins, allowing configuration as either input or output. It supports both read and write operations.</p>
</li>
<li>
<p><strong>GPIO_DATA_REG (`h08)</strong>:
This register, accessible in 32, 16, or 8 bits, serves as the GPIO Data Register. It supports read and write operations, facilitating data handling for GPIO pins.</p>
</li>
<li>
<p><strong>Sequence of Execution</strong>:</p>
<ul>
<li>To effectively utilize the GPIO functionality, follow this sequence:
<ul>
<li>Write into the GPIO Direction register (GPIO_DIRECTION_CNTRL_REG) to configure the GPIO pin as an input or output.</li>
<li>Write appropriate values to the GPIO Data register (GPIO_DATA_REG) based on the desired input or output data.</li>
</ul>
</li>
</ul>
<p>These steps ensure proper configuration and operation of the GPIO pins, making them valuable for a wide range of applications in signal processing and interrupt-driven scenarios.</p>
</li>
</ul>
<h3 id="rust-gpio-register-implmentation"><a class="header" href="#rust-gpio-register-implmentation">Rust GPIO Register implmentation</a></h3>
<pre><code>
use crate::common::MMIODerefWrapper;
use riscv::{
    asm::{delay, nop},
    register,
};
use tock_registers::{
    interfaces::{Readable, Writeable},
    register_bitfields, register_structs,
    registers::{ReadOnly, ReadWrite, WriteOnly},
};

//--------------------------------------------------------------------------------------------------
// Private Definitions
//--------------------------------------------------------------------------------------------------

pub const GPIO_OFFSET: usize = 0x0004_0100;

register_structs! {
    #[allow(non_snake_case)]
    pub RegistersBlock{
        (0x00 =&gt; DIRECTION_CR_REG: ReadWrite&lt;u32&gt;),
        (0x04 =&gt; _reserved0),
        (0x08 =&gt; DATA_REG: ReadWrite&lt;u32&gt;),
        (0x0C =&gt; @END),
    }
}

register_bitfields! {
    u32,

    DIRECTION_CR_REG [
        CR OFFSET(0) NUMBITS(32) []
    ],
    SCL[
        DATA_REG OFFSET(0) NUMBITS(32) []
    ],

}

type Registers = MMIODerefWrapper&lt;RegistersBlock&gt;;

pub struct GPIOInner {
    registers: Registers,
}


</code></pre>
<ul>
<li><strong>Memory-Mapped I/O (MMIO)</strong>:</li>
</ul>
<p>use crate::common::MMIODerefWrapper: Imports a wrapper for MMIO, which is a technique for interfacing with hardware registers by mapping them to specific memory addresses.</p>
<ul>
<li><strong>RISC-V Assembly and Registers</strong>:</li>
</ul>
<p>use riscv::{asm::{delay, nop}, register}: Imports RISC-V assembly instructions (delay, nop) and register-related functionality. RISC-V is an instruction set architecture commonly used in embedded systems.</p>
<ul>
<li><strong>Tock Registers</strong>:</li>
</ul>
<p>use tock_registers::{interfaces::{Readable, Writeable}, register_bitfields, register_structs, registers::{ReadOnly, ReadWrite, WriteOnly}};: Imports Tock Registers, a library for working with hardware registers in embedded systems. It provides traits for reading and writing registers, as well as utilities for defining register bitfields.</p>
<ul>
<li><strong>GPIO Offset</strong>:</li>
</ul>
<p>pub const GPIO_OFFSET: usize = 0x0004_0100;: Defines the offset for GPIO registers in memory.</p>
<ul>
<li><strong>Register Block Definition</strong>:</li>
</ul>
<p>register_structs! { ... }: Defines a block of memory-mapped registers for GPIO. This includes the Direction Control Register (DIRECTION_CR_REG) and Data Register (DATA_REG), specifying their offsets and types.</p>
<ul>
<li><strong>Register Bitfields</strong>:</li>
</ul>
<p>register_bitfields! { ... }: Defines specific bitfields within the registers, such as the CR field in the Direction Control Register and the DATA_REG field in the Data Register.</p>
<ul>
<li><strong>Registers Wrapper</strong>:</li>
</ul>
<p>type Registers = MMIODerefWrapper<RegistersBlock>;: Defines a type Registers that wraps the MMIO registers, providing a safe interface for accessing and modifying them.</p>
<ul>
<li><strong>GPIOInner Structure</strong>:</li>
</ul>
<p>pub struct GPIOInner { registers: Registers, }: Defines a structure encapsulating the GPIO registers. This structure is likely used to abstract GPIO operations and provide a more organized interface.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart"><a class="header" href="#uart">UART</a></h1>
<p>The UART module in the Shakti SoC (System on Chip) provides asynchronous serial communication with RS-232 (RS-422/485) interface. It operates in a non-return-to-zero (NRZ) mode, supporting data transfer rates that can be configured through the UARTBAUD register. Here's a concise overview of key UART registers and their functionalities:</p>
<h3 id="uart-registers"><a class="header" href="#uart-registers">UART Registers</a></h3>
<ol>
<li><strong>BAUD Register (Address: 0x00)</strong>
Configures the Baud rate based on the set Baud value.
Baud Rate calculation: Baud_value = (Clock Frequency) / (16 * Baudrate)</li>
<li><strong>Status Register (Address: 0x0C)</strong>
Provides status information about transmit and receive operations.
Break, frame, overrun, and parity error flags.
Flags indicating receiver and transmitter buffer status.</li>
<li><strong>Control Register (Address: 0x14)</strong>
Configures UART operation, character size, parity, and stop bits.
Character size (data length), parity, and stop bits settings.</li>
<li><strong>TX_REG Register (Address: 0x04)</strong>
Write-only register for transmitting data. Data to be transmitted is written into this register.</li>
<li><strong>RCV_REG Register (Address: 0x08)</strong>
Read-only register for receiving data. The received value can be read from this register.</li>
<li><strong>IEN Register (Address: 0x18)</strong>
Enables interrupts based on the set bit values in the Interrupt Enable Register.
Interrupts for various conditions like threshold, break error, frame error, overrun, parity error, and buffer status.</li>
<li><strong>DELAY Register (Address: 0x10)</strong>
Controls delayed transmit by specifying the required delay count.</li>
<li><strong>IQCYCLES Register (Address: 0x1C)</strong>
Holds the number of input qualification cycles for the receiver pin.</li>
<li><strong>RX_THRESHOLD Register (Address: 0x20)</strong>
Holds the receiver FIFO threshold value. Generates corresponding status bits and interrupts when the FIFO level crosses the threshold.
These registers collectively define the configuration, status, and control aspects of the UART module in the Shakti SoC, facilitating efficient and configurable serial communication.</li>
</ol>
<h3 id="rust-uart-register-implmentation"><a class="header" href="#rust-uart-register-implmentation">Rust UART Register implmentation</a></h3>
<pre><code>use crate::common::MMIODerefWrapper;
use riscv::{
    asm::{delay, nop},
    register,
};
use tock_registers::{
    interfaces::{Readable, Writeable},
    register_bitfields, register_structs,
    registers::{ReadOnly, ReadWrite, WriteOnly},
};

//--------------------------------------------------------------------------------------------------
// Private Definitions
//--------------------------------------------------------------------------------------------------

pub const UART_OFFSET: usize = 0x0001_1300;
pub const STS_TX_FULL_FLAG: u8 = 0x02;
pub const STS_RX_NOT_EMPTY_FLAG: u8 = 0x08;

pub const BREAK_ERROR: u8 = 1 &lt;&lt; 7;
pub const FRAME_ERROR: u8 = 1 &lt;&lt; 6;
pub const OVERRUN: u8 = 1 &lt;&lt; 5;
pub const PARITY_ERROR: u8 = 1 &lt;&lt; 4;
pub const STS_RX_FULL: u8 = 1 &lt;&lt; 3;
pub const STS_RX_NOT_EMPTY: u8 = 1 &lt;&lt; 2;
pub const STS_TX_FULL: u8 = 1 &lt;&lt; 1;
pub const STS_TX_EMPTY: u8 = 1 &lt;&lt; 0;

register_structs! {
    #[allow(non_snake_case)]
    pub RegistersBlock{
        (0x00 =&gt; UBR: ReadWrite&lt;u16&gt;),
        (0x02 =&gt; _reserved0),
        (0x04 =&gt; TX_REG: WriteOnly&lt;u32&gt;),
        (0x08 =&gt; RCV_REG: ReadOnly&lt;u32, RCV_REG::Register&gt;),
        (0x0C =&gt; USR : ReadOnly&lt;u8, USR::Register&gt;),
        (0x0D =&gt; _reserved1),
        //(0x0E =&gt; _reserved2),
        (0x10 =&gt; DELAY: ReadWrite&lt;u32, DELAY::Register&gt;),
        // (0x12 =&gt; _reserved3),
        (0x14 =&gt; UCR: ReadWrite&lt;u32, UCR::Register&gt;),
        // (0x16 =&gt; _reserved4),
        (0x18 =&gt; IEN: ReadWrite&lt;u32, IEN::Register&gt;),
        // (0x1A =&gt; _reserved5),
        (0x1C =&gt; IQCYCLES: ReadWrite&lt;u32, IQCYCLES::Register&gt;),
        // (0x1D =&gt; _reserved6),
        // (0x1E =&gt; _reserved7),
        // (0x1F =&gt; _reserved11),
        (0x20 =&gt; RX_THRESHOLD: WriteOnly&lt;u32, RX_THRESHOLD::Register&gt;),
        // (0x21 =&gt; _reserved8),
        // (0x22 =&gt; _reserved9),
        // (0x23 =&gt; _reserved10),
        (0x24 =&gt; @END),
    }
}

register_bitfields! {
    u32,

    UBR [
        BAUD OFFSET(0) NUMBITS(16) []
    ],

    /// UART Status register
    USR [
        /// Transmit FIFO empty. The meaning of this bit depends on the state of the FEN bit in the
        /// Line Control Register, LCR_H.
        ///
        /// - If the FIFO is disabled, this bit is set when the transmit holding register is empty.
        /// - If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is empty.
        /// - This bit does not indicate if there is data in the transmit shift register.
        BREAK_ERROR OFFSET(7) NUMBITS(1) [],
        ///Break Error (Sets when the data and stop are both zero
        FRAME_ERROR OFFSET(6) NUMBITS(1) [],
        ///Frame Error (Sets when the stopis zero)
        OVERRUN OFFSET(5) NUMBITS(1) [],
        ///Overrun Error (A data overrun error occurred in the receive
        ///shift register. This happens when additional data arrives
        ///while the FIFO is full. )
        PARITY_ERROR OFFSET(4) NUMBITS(1) [],
        ///Parity Error (Sets when The receive character does not
        ///have correct parity information and is suspect.

        STS_RX_FULL OFFSET(3) NUMBITS(1) [],
        ///Receiver Full (Sets when the Receive Buffer is Full)

        STS_RX_NOT_FULL OFFSET(2) NUMBITS(1) [],
        /// Receiver Not Empty (Sets when there is some data in the
        ///Receive Buffer).
        STS_TX_FULL OFFSET(1) NUMBITS(1) [
            EMPTY = 0,
            FULL = 1,
        ],
        ///Transmitter Full (Sets when the transmit Buffer is full)
        STS_TX_EMPTY OFFSET(0) NUMBITS(1) [
            EMPTY = 1,
            FULL = 0,
        ]
        //Transmitter Empty(Sets when the Transmit Buffer is empty).
    ],

    UCR [
        UART_TX_RX_LEN OFFSET(5) NUMBITS(6) [],
        //Character size of data. Maximum length is 32 bits.
        PARITY OFFSET(3) NUMBITS(2) [
            None = 0b00,
            Odd = 0b01,
            Even = 0b10,
            Unused = 0b11

        ],
         //Insert Parity bits
         //00 - None
         //01 - Odd
        //10- Even
        // 11 - Unused or Undefined
        STOP_BITS OFFSET(1) NUMBITS(2) [

            StopBits1 = 0b00,
            StopBits1_5 = 0b01,
            StopBits2 = 0b10


        ],
        //Stop bits
       //00 - 1 Stop bits
        //01 - 1.5 Stop bits
        //10 - 2 Stop bits
    ],

    TX_REG [

        TX_DATA OFFSET(0) NUMBITS(32) []
    ],


    RCV_REG [

        RX_DATA OFFSET(0) NUMBITS(32) []
    ],

    IEN [

        ENABLE_TX_EMPTY OFFSET(0) NUMBITS(1) [],
        ENABLE_TX_FULL OFFSET(1) NUMBITS(1) [],
        ENABLE_RX_NOT_EMPTY OFFSET(2) NUMBITS(1) [],
        ENABLE_RX_FULL OFFSET(3) NUMBITS(1) [],
        ENABLE_PARITY_ERROR OFFSET(4) NUMBITS(1) [],
        ENABLE_OVERRUN OFFSET(5) NUMBITS(1) [],
        ENABLE_FRAME_ERROR OFFSET(6) NUMBITS(1) [],
        ENABLE_BREAK_ERROR OFFSET(7) NUMBITS(1) [],
        ENABLE_RX_THRESHOLD OFFSET(8) NUMBITS(1) []
    ],
///Delayed Transmit control is done by providing the required delay in UART DELAY register.
      DELAY [
        COUNT OFFSET(0) NUMBITS(8) []
      ],
///UART IQCYCLES Register holds the number of input qualification cycles for the receiver pin. .
      IQCYCLES[
        COUNT OFFSET(0) NUMBITS(8) []
      ],
    RX_THRESHOLD [
        /// UART RX_THRESHOLD register holds the receiver FIFO threshold value, when the RX FIFO
        ///level increases beyond the threshold, corresponding status bit will be set and when interrupt is
       ///enabled, interrupt will be raised
        FIFO_RX OFFSET(0) NUMBITS(8) []
    ]

}
/// Abstraction for the associated MMIO registers.
type Registers = MMIODerefWrapper&lt;RegistersBlock&gt;;

pub struct UartInner {
    registers: Registers,
}


</code></pre>
<ul>
<li><strong>Dependencies</strong>:</li>
</ul>
<p>The code relies on the MMIODerefWrapper from the common module.
It uses various modules and traits from the riscv and tock_registers crates.</p>
<ul>
<li><strong>Register Definitions</strong>:</li>
</ul>
<p>The RegistersBlock struct defines memory-mapped I/O (MMIO) registers for the UART module.
Register addresses and their offsets are specified, along with their bitfields.</p>
<ul>
<li><strong>Constants</strong>:</li>
</ul>
<p>UART_OFFSET: Specifies the offset for the UART module in memory.
Flags and error constants such as STS_TX_FULL_FLAG, STS_RX_NOT_EMPTY_FLAG, BREAK_ERROR, etc., are defined.</p>
<ul>
<li><strong>Register Bitfields</strong>:</li>
</ul>
<p>The register_bitfields! macro is used to define bitfields for various registers.
It provides convenient access to specific bits within the registers.</p>
<ul>
<li><strong>Register Types</strong>:</li>
</ul>
<p>Read, Write, and ReadWrite traits are implemented for certain register types, indicating their accessibility.</p>
<ul>
<li><strong>Structs</strong>:</li>
</ul>
<p>RegistersBlock: Represents the MMIO registers for the UART module.
UartInner: Encapsulates the inner workings of the UART, including access to MMIO registers.</p>
<ul>
<li><strong>Struct Initialization</strong>:</li>
</ul>
<p>Registers: A wrapper around RegistersBlock, providing safe access to the MMIO registers.
UartInner: Contains a Registers instance.</p>
<p>This code essentially establishes a clear abstraction for working with the UART module in the Shakti RISC-V processor, allowing developers to interact with the UART hardware through safe and well-defined Rust abstractions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spi"><a class="header" href="#spi">SPI</a></h1>
<p>The SPI (Serial Peripheral Interface) is a synchronous serial I/O (Input/Output) port commonly used for communication between microcontrollers and peripheral devices. Here's a breakdown of the SPI registers for a Shakti RISC-V processor:</p>
<h2 id="spi-registers"><a class="header" href="#spi-registers">SPI Registers</a></h2>
<ul>
<li><strong>SPI_CR1 (Offset: 'h00)</strong>   : 32 bits, Read and Write - SPI Control Register 1.</li>
<li><strong>SPI_CR2 (Offset: 'h04)</strong>   : 32 bits, Read and Write - SPI Control Register 2.</li>
<li><strong>SPI_SR (Offset: 'h08)</strong>    : 32 bits, Read Only - SPI Status Register.</li>
<li><strong>SPI_DR1 (Offset: 'h0C)</strong>   : 32 bits, Read and Write - SPI Data Register 1.</li>
<li><strong>SPI_DR2 (Offset: 'h10)</strong>   : 32 bits, Read and Write - SPI Data Register 2.</li>
<li><strong>SPI_DR3 (Offset: 'h14)</strong>   : 32 bits, Read and Write - SPI Data Register 3.</li>
<li><strong>SPI_DR4 (Offset: 'h18)</strong>   : 32 bits, Read and Write - SPI Data Register 4.</li>
<li><strong>SPI_DR5 (Offset: 'h1C)</strong>   : 32 bits, Read and Write - SPI Data Register 5.</li>
<li><strong>SPI_CRCPR (Offset: 'h20)</strong> : 32 bits, Reserved - SPI CRC Polynomial Register.</li>
<li><strong>SPI_RXCRCR (Offset: 'h24)</strong>: 32 bits, Reserved - SPI RX CRC Register.</li>
<li><strong>SPI_TXCRCR (Offset: 'h28)</strong>: 32 bits, Reserved - SPI TX CRC Register.</li>
</ul>
<p>These registers control various aspects of the SPI module, including data transfer, CRC (Cyclic Redundancy Check), and status information. Developers can interact with these registers to configure and manage SPI communication in their applications.</p>
<h3 id="rust-spi-register-implmentation"><a class="header" href="#rust-spi-register-implmentation">Rust SPI Register implmentation</a></h3>
<pre><code>
use riscv::asm::delay;
use tock_registers::{
    fields::FieldValue,
    interfaces::{ReadWriteable, Readable, Writeable},
    register_bitfields, register_structs,
    registers::{ReadOnly, ReadWrite, WriteOnly},
};

use crate::common::MMIODerefWrapper;

use self::SPI_CR1::SPI_TOTAL_BITS_TX;

pub const SPI_OFFSET: usize = 0x0002_0000;

register_bitfields! {
    u32,

    SPI_CR1 [

        /// Expected Total Number of bits to be received.
        SPI_TOTAL_BITS_RX OFFSET(24) NUMBITS(8) [

        ],

        /// Total Number of bits to be transmitted.
        SPI_TOTAL_BITS_TX OFFSET(16) NUMBITS(8) [

        ],

        /// Bidirectional data mode enable. This bit enables
        /// half-duplex communication using a common single
        /// bidirectional data line.
        /// 0: 2-line unidirectional data mode selected
        /// 1: 1-line unidirectional data mode selected
        SPI_BIDIMODE OFFSET(15) NUMBITS(1) [
            OUTPUT_ENABLE = 1,
            PUTPUT_DISABLE = 0,
        ],

        /// Output enable in bidirectional mode This bit combined with
        /// the BIDI-MODE bit selects the direction of transfer in bi-direction mode.
        /// 0: receive-only mode (Output Disabled)
        /// 1: transmit-only mode (Output Enabled)
        SPI_BIDIODE OFFSET(14) NUMBITS(1) [
            OUTPUT_ENABLE = 1,
            PUTPUT_DISABLE = 0,
        ],


        /// Hardware CRC calculation Enable.
        /// 0: CRC calculation disable
        /// 1: CRC calculation enable
        SPI_CRCEN OFFSET(13) NUMBITS(1) [
            HWCRC_ENABLE = 1,
            HWCRC_DISABLE = 0,
        ],

        /// Transmit CRC Next.
        /// 0: Next Transmit value is from Tx buffer
        /// 1: Next Transmit value is from Rx buffer
        SPI_CCRCNEXT OFFSET(12) NUMBITS(1) [
            CRCNEXT_RX = 1,
            CRCNEXT_TX = 0,
        ],

        /// CRC Length bit is set and cleared by software to select CRC Length
        SPI_CRCL OFFSET(11) NUMBITS(1) [

        ],

        /// Receive only mode enabled. This bit enables simplex
        /// communication using a single unidirectional line to
        /// receive data exclusively. Keep BIDIMODE bit clear when
        /// receiving the only mode is active.
        SPI_RXONLY OFFSET(10) NUMBITS(1) [

        ],

        /// Software Slave Management. When the SSM bit is set,
        /// the NSS pin input is replaced with the value from the SSI
        /// bit.
        /// 0: Software slave management disabled
        /// 1: Software slave management enabled
        SPI_SSM OFFSET(9) NUMBITS(1) [
            SSM_ENABLED  = 1,
            SSM_DISABLED = 0,
        ],

        /// Internal Slave Select.This bit has an effect only when the
        /// SSM bit is set. The value of this bit is forced onto the
        /// NSS pin and the I/O value of the NSS pin is ignored
        SPI_SSI OFFSET(8) NUMBITS(1) [

        ],

        /// Frame Format
        /// 0: data is transmitted/received with the MSB first
        /// 1: data is transmitted/received with the LSB first
        /// Note: This bit should not be changed when communication is ongoing
        SPI_LSBFIRST OFFSET(7) NUMBITS(1) [
            LSB_FIRST = 1,
            MSB_FIRST = 0,
        ],

        /// SPI Enable
        /// 0: SPI is disabled
        /// 1: SPI is enabled
        SPI_SPE OFFSET(6) NUMBITS(1) [
            ENABLED  = 1,
            DISABLED = 0,
        ],

        /// Baud Rate Control
        /// 000: fCLK/2
        /// 001: fCLK/4
        /// 010: fCLK/8
        /// 011: fCLK/16
        /// 100: fCLK/32
        /// 101: fCLK/64
        /// 110: fCLK/128
        /// 111: fCLK/256
        /// Note:This bit should not be changed when communication is ongoing
        SPI_BR OFFSET(3) NUMBITS(3) [

        ],

        /// Master Selection
        /// 0: Slave Configuration
        /// 1: Master Configuration
        /// Note This bit should not be changed when communication is ongoing
        SPI_MSTR OFFSET(2) NUMBITS(1) [
            SLAVE_CONFIG   = 1,
            MASTER_CONFIG  = 0,
        ],

        ///Clock Polarity
        ///0: CLK is 0 when idle
        ///1: CLK is 1 when idle
        SPI_CPOL OFFSET(1) NUMBITS(1) [
            ONE_IDLE   = 1,
            ZERO_IDLE  = 0,
        ],

        ///Clock Phase
        ///0: The first clock transition is the first data capture edge
        ///1: The second clock transition is the first data capture edge
        SPI_CPHA OFFSET(0) NUMBITS(1) [
            SECOND_CLK = 1,
            FIRST_CLK  = 0,
        ]
    ],

    SPI_CR2 [
        ///SPI_TOTAL_BITS_RX OFFSET(24) NUMBITS(7) [],
        SPI_RX_IMM_START OFFSET(16) NUMBITS(1) [],
        SPI_RX_START OFFSET(15) NUMBITS(1) [],
        SPI_LDMA_TX_START OFFSET(14) NUMBITS(1) [],
        SPI_LDMA_RX OFFSET(13) NUMBITS(1) [],

        /// FIFO reception threshold is used to set the threshold of
        /// the RXFIFO that triggers an RXNE event.
        /// 0: RXNE event is generated if the FIFO level is greater
        /// than or equal to 1/2 (16-bit)
        /// 1: RXNE event is generated if the FIFO level is greater
        /// than or equal to 1/4 (8-bit)
        SPI_FRXTH OFFSET(12) NUMBITS(1) [],

        /// Reserved bits
        /// SPI_DS OFFSET(8) NUMBITS(4) [],

        /// Interrupt enable for TXE event.
        /// 0: TXE interrupt masked
        /// 1: TXE interrupt is not interrupt masked
        SPI_TXEIE OFFSET(7) NUMBITS(1) [],

        /// Interrupt enable for RXNE event
        /// 0: RXNE interrupt masked
        /// 1: RXNE interrupt is not interrupt masked
        SPI_RXNEIE OFFSET(6) NUMBITS(1) [
            RXNE_UNMASKED = 1,
            RXNE_MASKED = 0,
        ],

        /// when an error condition occurs.
        /// 0: Error interrupt masked
        /// 1: Error interrupt not masked.
        //Frame Error (Sets when the stopis zero)
        SPI_ERRIE OFFSET(5) NUMBITS(1) [
            MASKED_INT   = 1,
            UNMASKED_INT = 0,
        ],

        /// Reserved bits
        /// SPI_FRF OFFSET(4) NUMBITS(1) [],
        /// SPI_NSSP OFFSET(3) NUMBITS(1) [],

        /// SS output enable
        /// 0: SS output is disabled in master mode and the SPI interface
        /// can work in a multi-master configuration
        /// 1: SS output is enabled in master mode and when the SPI
        /// interface is enabled. The SPI interface cannot work in a
        /// multi-master environment.
        SPI_SSOE OFFSET(2) NUMBITS(1) [
            SSOE_ENABLED  = 1,
            SSOE_DISABLED = 0,
        ],

        // Reserved bits
        // SPI_TXDMAEN OFFSET(1) NUMBITS(1) [],
        // SPI_RXDMAEN OFFSET(0) NUMBITS(1) [],

    ],

    SPI_SR[

        SPI_FTLVL OFFSET(11) NUMBITS(2) [],
        SPI_FRLVL OFFSET(9) NUMBITS(2) [],

        SPI_FRE OFFSET(8) NUMBITS(1) [],
        SPI_BSY OFFSET(7) NUMBITS(1) [],
        SPI_OVR OFFSET(6) NUMBITS(1) [],

        SPI_MODF OFFSET(5) NUMBITS(1) [],

        SPI_CRCERR OFFSET(4) NUMBITS(1) [],

        SPI_TXE OFFSET(1) NUMBITS(1) [],

        SPI_RXNE OFFSET(0) NUMBITS(1) []

    ],

    SPI_DR1 [
        DR1 OFFSET(0) NUMBITS(32) []
    ],

    SPI_DR2 [
        DR2 OFFSET(0) NUMBITS(32) []
    ],

    SPI_DR3 [
        DR3 OFFSET(0) NUMBITS(32) []
    ],

    SPI_DR4 [
        DR4 OFFSET(0) NUMBITS(32) []
    ],

    SPI_DR5 [
        DR5 OFFSET(0) NUMBITS(32) []
    ],


}

register_structs! {
    #[allow(non_snake_case)]
    pub RegisterBlock{
        (0x00 =&gt; SPI_CR1: ReadWrite&lt;u32, SPI_CR1::Register&gt;),
        (0x04 =&gt; SPI_CR2: ReadWrite&lt;u32, SPI_CR2::Register&gt;),
        (0x08 =&gt; SPI_SR:  ReadOnly &lt;u32, SPI_SR ::Register&gt;),
        (0x0C =&gt; SPI_DR1: ReadWrite &lt;u32, SPI_DR1::Register&gt;),
        (0x10 =&gt; SPI_DR2: ReadWrite &lt;u32, SPI_DR2::Register&gt;),
        (0x14 =&gt; SPI_DR3: ReadWrite &lt;u32, SPI_DR3::Register&gt;),
        (0x18 =&gt; SPI_DR4: ReadWrite &lt;u32, SPI_DR4::Register&gt;),
        (0x1C =&gt; SPI_DR5: ReadWrite &lt;u32, SPI_DR5::Register&gt;),
        (0x20 =&gt; _reserved),
        (0x2C =&gt; @END),
    }
}

/// Abstraction for the associated MMIO registers.
type Registers = MMIODerefWrapper&lt;RegisterBlock&gt;;

pub struct SPIInner {
    registers: Registers,
}

</code></pre>
<p>The code includes necessary dependencies from tock_registers and defines a constant SPI_OFFSET representing the memory-mapped offset for the SPI module.</p>
<p><strong>Bitfields Definition</strong>
The code defines bitfields for various SPI registers <strong>(SPI_CR1, SPI_CR2, SPI_SR, SPI_DR1, SPI_DR2, SPI_DR3, SPI_DR4, SPI_DR5)</strong>. Each register has different bitfields representing configuration options and status flags.</p>
<p><strong>Register Structures</strong>
The code uses the register_structs! macro to define the memory-mapped register block for the SPI module. It includes registers like <strong>SPI_CR1, SPI_CR2, SPI_SR, SPI_DR1, SPI_DR2, SPI_DR3, SPI_DR4, and SPI_DR5</strong>. Each register is associated with its offset in memory, and their types are specified based on read or write access and the bitfields defined earlier.</p>
<p><strong>SPIInner Struct</strong>
The SPIInner struct is defined to encapsulate the SPI module's registers. It contains a field registers of type <strong>MMIODerefWrapper<RegisterBlock></strong>, providing a convenient way to access the SPI module's registers.</p>
<p>Overall, the code sets up a structured representation of the SPI module's registers with bitfields and provides an abstraction (SPIInner) for interacting with these registers. It's a common pattern in embedded systems programming to use such abstractions to manage hardware peripherals.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i2c"><a class="header" href="#i2c">I2C</a></h1>
<p><strong>Shakti processors</strong>, which are based on the <strong>RISC-V architecture</strong>, the I2C (Inter-Integrated Circuit) interface is commonly used to connect low-speed devices within embedded systems. The I2C module in Shakti processors typically includes several registers that control and manage the communication on the I2C bus. Here's a general overview of the I2C module for Shakti:</p>
<h2 id="i2c-registers"><a class="header" href="#i2c-registers">I2C Registers:</a></h2>
<ul>
<li>
<p><strong>Prescale Register</strong> (Prescale - Offset 0x00):
Size: 8 bits
Accessible: Read/Write
Description: Configures the I2C prescaler, which divides the system clock to determine the I2C clock frequency.</p>
</li>
<li>
<p><strong>Control Register</strong> (Control - Offset 0x08):
Size: 8 bits
Accessible: Read/Write
Description: Configures and controls the I2C data transfer. Key bits include:
<strong>I2C_PIN</strong>: Pending Interrupt Not, Used as a software reset.
<strong>I2C_ENI</strong>: Enables the external interrupt output.
<strong>I2C_STA</strong>: Transmits Start condition + Slave address.
<strong>I2C_STO</strong>: Transmits the stop condition.
<strong>I2C_ACK</strong>: Acknowledgement bit.</p>
</li>
<li>
<p><strong>Data Shift Register</strong> (Data - Offset 0x10):
Size: 8 bits
Accessible: Read/Write
Description: Holds the data to be transmitted or received during I2C communication.</p>
</li>
<li>
<p><strong>Status Register</strong> (Status - Offset 0x18):
Size: 8 bits
Accessible: Read
Description: Provides the status of I2C data transfer. Key bits include:
<strong>I2C_INI</strong>: High when I2C communication is in progress.
<strong>I2C_STS</strong>: Status flag in slave receiver mode for externally generated STOP condition.
<strong>I2C_BER</strong>: Bus error flag for misplaced START or STOP condition.
<strong>I2C_AD0/I2C_LRB</strong>: Last Received Bit and Address 0 in slave mode.
<strong>I2C_AAS</strong>: Addressed As Slave bit.
<strong>I2C_LAB</strong>: Lost Arbitration Bit.
<strong>I2C_BB</strong>: Bus Busy bit.</p>
</li>
<li>
<p><strong>Clock Register</strong> (SCL - Offset 0x38):
Size: 8 bits
Accessible: Read/Write
Description: Divides the I2C Prescaler clock to determine the I2C SCL (Serial Clock Line) frequency.</p>
</li>
<li>
<p><strong>General Overview</strong>:</p>
<ul>
<li>I2C is used for connecting low-speed devices in embedded systems.</li>
<li>It facilitates communication between a single master and multiple slave devices.</li>
<li>Two-wire interface: SDA (Data) and SCL (Clock).</li>
<li>Each device has a unique address.</li>
<li>Synchronous communication with master controlling the clock.</li>
<li>Registers control prescaling, data transfer, status, and clock frequency.</li>
</ul>
</li>
</ul>
<h3 id="rust-i2c-register-implmentation"><a class="header" href="#rust-i2c-register-implmentation">Rust I2C Register implmentation</a></h3>
<pre><code>use crate::common::MMIODerefWrapper;
use riscv::{
    asm::{delay, nop},
    register,
};
use tock_registers::{
    interfaces::{Readable, Writeable},
    register_bitfields, register_structs,
    registers::{ReadOnly, ReadWrite, WriteOnly},
};

//--------------------------------------------------------------------------------------------------
// Private Definitions
//--------------------------------------------------------------------------------------------------

pub const I2C_OFFSET: usize = 0x0004_0000;

pub const I2C_INI: u8 = 1 &lt;&lt; 7;
pub const I2C_STS: u8 = 1 &lt;&lt; 5;
pub const I2C_BER: u8 = 1 &lt;&lt; 4;
pub const I2C_AD0_LRB: u8 = 1 &lt;&lt; 3;
pub const I2C_AAS: u8 = 1 &lt;&lt; 2;
pub const I2C_LAB: u8 = 1 &lt;&lt; 1;
pub const I2C_BB: u8 = 1 &lt;&lt; 0;

pub const I2C_PIN: u8 = 1 &lt;&lt; 7;
pub const I2C_ES0: u8 = 1 &lt;&lt; 6;
pub const I2C_ENI_LRB: u8 = 1 &lt;&lt; 3;
pub const I2C_STA: u8 = 1 &lt;&lt; 2;
pub const I2C_STO: u8 = 1 &lt;&lt; 1;
pub const I2C_ACK: u8 = 1 &lt;&lt; 0;

register_structs! {
    #[allow(non_snake_case)]
    pub RegistersBlock{
        (0x00 =&gt; PRESCALE: ReadWrite&lt;u16&gt;),
        (0x02 =&gt; _reserved0),
        (0x08 =&gt; CONTROL: ReadWrite&lt;u8&gt;),
        (0x09 =&gt; _reserved1),
        (0x10 =&gt; DATA: ReadWrite&lt;u8&gt;),
        (0x11 =&gt; _reserved2),
        (0x18 =&gt; STATUS : ReadWrite&lt;u8&gt;),
        (0x19 =&gt; _reserved3),
        (0x38 =&gt; SCL : ReadWrite&lt;u8&gt;),
        (0x39 =&gt; _reserved4)
,       (0x3C =&gt; @END),
    }
}

register_bitfields! {
    u32,
///I2C Prescale Register divides the System clock by (Prescale value + 1). This clock is used as
///clock input for I2C Serial Clock.
///I2C Prescaler clock = System Clock / (Prescaler Value + 1)
    PRESCALE [
        PRESCALE_VALUE OFFSET(0) NUMBITS(8) []
    ],
    ///I2C SCL Register divides the I2C Prescaler clock by (SCL value + 1). This clock is used as
///I2C SCL clock = I2C Prescaler Clock / (SCL COUNT + 1).
    SCL[
        SCL_COUNT OFFSET(0) NUMBITS(8) []
    ],
    STATUS [
///High when I2C communication in progress. Becomes low once I2C
///communication is complete.
        I2C_INI OFFSET(7) NUMBITS(1) [],
   ///     When in slave receiver mode, this flag is asserted when an
      ///  externally generated STOP condition is detected (used only in
       /// slave receiver mode).
        I2C_STS OFFSET(5) NUMBITS(1) [],
///Bus error; a misplaced START or STOP condition has been
///detected
        I2C_BER OFFSET(4) NUMBITS(1) [],
     /*    AD0(Address 0) - General Call bit used for Broadcast
        LRB - Last Received Bit through I2C Bus
        This status bit serves a dual function, and is valid only while
        PIN = 0:
        1. LRB holds the value of the last received bit over the
        I2C-bus while AAS = 0 (not addressed as slave). Normally
        this will be the value of the slave acknowledgement; thus
        checking for slave acknowledgement is done via testing of the
        LRB.
        2. AD0; when AAS = 1 (‘Addressed As Slave’ condition), the
        I2C-bus controller has been addressed as a slave. Under this
        condition, this bit becomes the ‘AD0’ bit and will be set to
        logic 1 if the slave address received was the ‘general call’
        (00H) address, or logic 0 if it was the I2C-bus controller’s own
        slave address.
        */
        I2C_AD0_LRB OFFSET(3) NUMBITS(1) [],
///Addressed As Slave’ bit. Valid only when PIN = 0. When
///acting as slave receiver, this flag is set when an incoming
///address over the I2C-bus matches the value in own address
//register
        I2C_AAS OFFSET(2) NUMBITS(1) [],
///Lost Arbitration Bit. This bit is set when, in multi-master
///operation, arbitration is lost to another master on the I2C-bus
        I2C_LAB OFFSET(1) NUMBITS(1) [],
///Bus Busy bit. This is a read-only flag indicating when the
///I2C-bus is in use. A zero indicates that the bus is busy, and
///access is not possible
        I2C_BB OFFSET(0) NUMBITS(1) []

    ],

    CONTROL [
///Pending Interrupt Not, Used as a software reset. If set to 1, all
    I2C_PIN OFFSET(7) NUMBITS(1) [],
   /// Enable Serial Output.
    ///0 - Registers can be initialized.
    ///1 - I2C Serial Transmission
    I2C_ES0 OFFSET(6) NUMBITS(1) [
        REGISTER_INITIALIZED = 0,
        I2C_SERIAL_TRANSMISSION = 1,
    ],
///Enables the external interrupt output, which is generated when
///the PIN is active (Low)
    I2C_ENI OFFSET(3) NUMBITS(1) [],
///Transmits Start condition + Slave address..
    I2C_STA OFFSET(2) NUMBITS(1) [],
///Transmits the stop condition.
    I2C_STO OFFSET(1) NUMBITS(1) [],
///Acknowledgement bit.
///1: I2C automatically sends an acknowledgement after a
///read/write transaction.
///0: I2C Master sends Negative Acknowledge to stop the I2C
///transfer
    I2C_ACK OFFSET(0) NUMBITS(1) [
        NAK = 0,
        ACK = 1,
    ]

],


}

type Registers = MMIODerefWrapper&lt;RegistersBlock&gt;;

pub struct I2CInner {
    registers: Registers,
}

</code></pre>
<p>Rust implementation for interacting with the I2C (Inter-Integrated Circuit) module on Shakti processors.</p>
<ul>
<li>
<p><strong>Constants</strong>:</p>
<ul>
<li><strong>I2C_OFFSET</strong>: Specifies the offset address for the I2C module in memory.</li>
<li>Various constants <strong>(I2C_INI, I2C_STS, etc.)</strong> represent bit positions in status and control registers.</li>
</ul>
</li>
<li>
<p><strong>Register Structures</strong></p>
<ul>
<li><strong>RegistersBlock</strong> : Defines the memory-mapped I2C registers.</li>
<li><strong>PRESCALE</strong>       : Configures the I2C prescaler for clock frequency.</li>
<li><strong>CONTROL</strong>        : Configures and controls I2C data transfer.</li>
<li><strong>DATA</strong>           : Holds data to be transmitted or received.</li>
<li><strong>STATUS</strong>         : Provides status information about I2C communication.</li>
<li><strong>SCL</strong>            : Configures the I2C SCL (Serial Clock Line) clock.
-<strong>Register Bitfields</strong>:</li>
<li><strong>register_bitfields!</strong> macro defines specific bits within registers.</li>
<li><strong>PRESCALE</strong>: PRESCALE_VALUE represents the prescaler value.</li>
<li><strong>SCL</strong>     : SCL_COUNT represents the count for dividing the I2C Prescaler clock.</li>
<li><strong>STATUS</strong>  : Defines various status bits such as **I2C_INI, I2C_STS, I2C_BER, **etc.</li>
<li><strong>CONTROL</strong> : Defines control bits such as **I2C_PIN, I2C_ES0, I2C_ENI, **etc.</li>
</ul>
</li>
<li>
<p><strong>MMIODerefWrapper and Structs</strong>:</p>
<ul>
<li><strong>MMIODerefWrapper</strong> : Represents a memory-mapped I/O (MMIO) wrapper for safe interaction with hardware registers.</li>
<li><strong>Registers</strong>        : A wrapper for the RegistersBlock, ensuring safe access to I2C registers.</li>
</ul>
</li>
<li>
<p><strong>I2CInner Struct</strong>:</p>
<ul>
<li><strong>I2CInner</strong>: A struct encapsulating the I2C module, containing an instance of the Registers wrapper.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pwm"><a class="header" href="#pwm">PWM</a></h1>
<p><strong>Pulse Width Modulators (PWM)</strong> are used for generating pulses with a variable duty cycle. The duty cycle and period of the pulse can be adjusted through specific registers. PWM is commonly used in embedded systems to control the speed of motors, regulate LED brightness, and perform other tasks requiring variable output.</p>
<h2 id="pwm-registers"><a class="header" href="#pwm-registers">PWM Registers</a></h2>
<ul>
<li><strong>PERIOD_REGISTER (0x00)</strong>:
<ul>
<li><strong>Size</strong>       : 16 bits</li>
<li><strong>Accessible</strong> : Read and Write</li>
<li><strong>Description</strong>: PWM Period Register. It defines the duration of the entire PWM cycle.</li>
</ul>
</li>
<li><strong>DUTY_REGISTER (0x04)</strong>:
<ul>
<li><strong>Size</strong>       : 16 bits</li>
<li><strong>Accessible</strong> : Read and Write</li>
<li><strong>Description</strong>: PWM Duty Register. It determines the ON time (or high time) of the PWM signal.</li>
</ul>
</li>
<li><strong>CONTROL_REGISTER (0x08)</strong>:
<ul>
<li><strong>Size</strong>       : 8 bits</li>
<li><strong>Accessible</strong> : Read and Write</li>
<li><strong>Description</strong>: PWM Control Register. This register is used for configuring and controlling PWM settings.</li>
</ul>
</li>
<li><strong>CLOCK_REGISTER (0x0C)</strong>:
<ul>
<li><strong>Size</strong>       : 16 bits</li>
<li><strong>Accessible</strong> : Read and Write</li>
<li><strong>Description</strong>: PWM Clock Register. It divides the system clock by the specified prescaler value.</li>
</ul>
</li>
<li><strong>PWM Control Register (CONTROL_REGISTER)</strong>:
<ul>
<li><strong>Bit 7 (RESET_COUNTER)</strong>    : Resets the PWM counter.</li>
<li><strong>Bit 5 (INTERRUPT)</strong>        : Indicates whether an interrupt has occurred.</li>
<li><strong>Bit 4 (PWM_OUTPUT_ENABLE)</strong>: Enables or disables PWM output.</li>
<li><strong>Bit 3 (CONTINUOUS_ONCE)</strong>  : Configures continuous or one-time operation in timer mode.</li>
<li><strong>Bit 2 (PWM_START)</strong>        : Starts the PWM operation.</li>
<li><strong>Bit 1 (PWM_ENABLE)</strong>       : Enables PWM or sets the timer mode.</li>
<li><strong>Bit 0 (CLOCK_SELECT)</strong>     : Selects the clock source (internal or external).</li>
</ul>
</li>
<li><strong>PWM Clock Register (CLOCK_REGISTER)</strong>:
<ul>
<li><strong>Bits 15:1 (PWM PRESCALER)</strong>: Prescale value to achieve the required clock speed. Formula: PWM Frequency = system clock / (2 * prescaler * period).</li>
</ul>
</li>
<li><strong>PWM Period Register (PERIOD_REGISTER)</strong>:
<ul>
<li><strong>Bits 15:1 (PWM PERIOD)</strong>   : Period value to determine the PWM period. Formula: PWM Period = 1 / PWM frequency.</li>
</ul>
</li>
<li><strong>PWM Duty Register (DUTY_REGISTER)</strong>:
<ul>
<li><strong>Bits 15:1 (PWM DUTY)</strong>     : ON time of the PWM period. Formula: ON (HIGH) of PWM DUTY = (Duty reg * PWM period) / PWM Period reg.
<strong>Example Calculation</strong>:
<strong>PWM Frequency</strong>: 1.688Hz
<strong>PWM Period</strong>   : 0.589824 seconds
<strong>PWM On time</strong>  : 0.3145728 seconds</li>
</ul>
</li>
<li><strong>Note</strong>:
The PWM module provides flexibility to adjust the PWM frequency, period, and duty cycle, allowing precise control over the generated pulses. These features make PWM valuable for various applications in embedded systems.</li>
</ul>
<h3 id="rust-i2c-register-implmentation-1"><a class="header" href="#rust-i2c-register-implmentation-1">Rust I2C Register implmentation</a></h3>
<pre><code>use crate::common::MMIODerefWrapper;
use riscv::{
    asm::{delay, nop},
    register,
};
use tock_registers::{
    interfaces::{Readable, Writeable},
    register_bitfields, register_structs,
    registers::{ReadOnly, ReadWrite, WriteOnly},
};

//--------------------------------------------------------------------------------------------------
// Private Definitions
//--------------------------------------------------------------------------------------------------

pub const PWM_OFFSET: usize = 0x0003_0000;

pub const RESET_COUNTER: u8 = 1 &lt;&lt; 7;
pub const INTERRUPT: u8 = 1 &lt;&lt; 5;
pub const PWM_OUTPUT_ENABLE: u8 = 1 &lt;&lt; 4;
pub const CONTINOUS_ONCE: u8 = 1 &lt;&lt; 3;
pub const PWMSTART: u8 = 1 &lt;&lt; 2;
pub const PWM_ENABLE: u8 = 1 &lt;&lt; 1;
pub const CLOCK_SELECT: u8 = 1 &lt;&lt; 0;

register_structs! {
    #[allow(non_snake_case)]
    pub RegistersBlock{
        (0x00 =&gt; PERIOD_REGISTOR: ReadWrite&lt;u16&gt;),
        (0x02 =&gt; _reserved0),
        (0x04 =&gt; DUTY_REGISTER: ReadWrite&lt;u16&gt;),
        (0x06 =&gt; _reserved1),
        (0x08 =&gt; CONTROL_REGISTER: ReadWrite&lt;u8&gt;),
        (0x09 =&gt; _reserved2),
        (0x0C =&gt; CLOCK_REGISTER : ReadWrite&lt;u16&gt;),
        (0x0E =&gt; _reserved3),
        (0x1C =&gt; @END),
    }
}


///Note:
///PWM Frequency = system clock / (2 * prescaler reg * period reg )
///= 50000000/(2 * 61440 * 240)
///= 1.688Hz
///PWM Period = 1 / PWM frequency
///= 1 / 1.688Hz = 0.589824 seconds
///PWM On time = (PWM Duty reg * PWM period ) / ( PWM Period reg)
///= 128 * 0.589824 / 240 = 0.3145728 seconds
register_bitfields! {
    u32,
///PWM PERIOD_REGISTER further divides the system clock by the (Prescaler value + 1).
    PERIOD_REGISER [
        PWM_PERIOD OFFSET(0) NUMBITS(16) []
    ],
    ///PWM Period = 1 / PWM frequency
    ///PWM Frequency = system clock / (2 * prescaler reg * period reg )
    DUTY_REGISTER[
        PWM_DUTY OFFSET(0) NUMBITS(16) []
    ],
    CONTROL_REGISTER [
        ///PWM Reset
        RESET_COUNTER OFFSET(7) NUMBITS(1) [],
    ///0: Interrupt not Occured.
///1: Interrupt occurred.
        INTERRUPT OFFSET(5) NUMBITS(1) [
            INTERRUPT_NOT_OCCURED = 0,
            INTERRUPT_OCCURED = 1,
        ],
///0: Disable PWM output
///1: Enable PWM output
        PWM_OUTPUT_ENABLE OFFSET(4) NUMBITS(1) [
            DISABLE_PWM_OUTPUT = 0,
            ENABLE_PWM_OUTPUT = 1,
        ],
///0: In timer mode, continuous mode is Off.
///1: In timer mode, continuous mode is ON.


        CONTINOUS_ONCE OFFSET(3) NUMBITS(1) [
            COUNTINOUS_MODE_OFF = 0,
            COUNTINOUS_MODE_ON  = 1,

        ],
///1:Start PWM Operation

        PWMSTART OFFSET(2) NUMBITS(1) [],
///0: Timer mode enable
///1: PWM enable
        PWM_ENABLE OFFSET(1) NUMBITS(1) [
            TIMER_NODE_ENABLE = 0,
            PWM_ENABLE = 1,
        ],
///0: Internal clock source selected
///1:External clock source selected
        CLOCK_SELECT OFFSET(0) NUMBITS(1) [
            INTERNAL_CLOCK_SOURCE_SELECTED = 0,
            EXTERNAL_CLOCK_SOURCE_SELECTED = 1,
        ]

    ],
///PWM CLOCK_REGISTER divides the system clock by the (Prescaler value + 1).
    CLOCK_REGISTER[
        PWM_PRESCALER OFFSET(1) NUMBITS(16) []
    ],


}


type Registers = MMIODerefWrapper&lt;RegistersBlock&gt;;

pub struct PWMInner {
    registers: Registers,
}

</code></pre>
<h2 id="registers"><a class="header" href="#registers">Registers</a></h2>
<ul>
<li>
<p><strong>Memory-Mapped I/O (MMIO)</strong>:
The code defines a struct, RegistersBlock, to represent the memory-mapped registers of the PWM module.
Register fields are defined using the register_structs! macro, creating a clear and concise representation of the hardware registers.</p>
</li>
<li>
<p><strong>Bitfield Abstraction</strong>:
The register_bitfields! macro is used to define bitfields within registers, simplifying bit-level operations.
Enums are used to represent possible values for specific bitfields, improving code readability.</p>
</li>
<li>
<p><strong>MMIODerefWrapper</strong>:
The MMIODerefWrapper type is employed to wrap memory-mapped registers, providing a safe and ergonomic interface for register access through dereferencing.</p>
</li>
<li>
<p><strong>Constants for Register Offsets and Bits</strong>:
Constants such as PWM_OFFSET, RESET_COUNTER, etc., are defined to enhance code readability and maintainability.
Bitwise operations and bit manipulation are abstracted using these constants.</p>
</li>
<li>
<p><strong>Initialization and Encapsulation</strong>:
The PWMInner struct encapsulates the registers, providing an abstraction for PWM control.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>The <strong>"shakti_rust_hal"</strong> crate has example section which serves code examples related to Shakti processors, and it is open for contributions from the community. This crate focuses on providing illustrative use cases and demonstrations of various functionalities using the Hardware Abstraction Layer (HAL). The HAL is a layer of code that abstracts the low-level details of hardware, making it easier for developers to interact with and utilize the underlying system.</p>
<p>Within this crate, you can find examples covering different peripherals and features, including GPIO (General Purpose Input/Output), UART (Universal Asynchronous Receiver-Transmitter), SPI (Serial Peripheral Interface), and potentially more. These examples showcase how to interface with and control these hardware components using Rust programming language constructs.</p>
<p>The openness to contributions implies that developers from the community can actively participate in enhancing, extending, or fixing issues within the crate. This collaborative approach fosters community-driven development, where individuals with diverse expertise can collectively improve the functionality, reliability, and versatility of the provided examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gpio-blinky"><a class="header" href="#gpio-blinky">GPIO blinky</a></h1>
<p>The Rust code controls LEDs using the Shakti platform's GPIO module. It defines a struct GPIO_ACCESS for GPIO operations, sets up constants for LEDs and GPIO registers, and implements methods to control LEDs. The main function initializes GPIO, enters a loop to toggle LEDs, and includes a simple delay function. The code provides a basic framework for LED control on the Shakti platform. Adjustments may be needed for specific GPIO configurations and timing accuracy.</p>
<pre><code>...
...
fn main() -&gt; !{

    let gpio_mmio_start_addr = 0x1000;
    
        
    let mut gpio_access = GPIO_ACCESS::new(); 
    gpio_access.set_direction(LED0_B|LED0_G|LED0_R|LED1_B|LED1_G|LED1_R|LED2|LED3);
    gpio_access.turn_off_ledx();  

        // Set the direction control register
    //gpio.set_direction_control(0x0);
    
        // Write to GPIO_DATA_REG to initialize GPIO pins
    //gpio.set_data_register(0x0); // Assuming initialization value is 0x0
    

    loop {
            delay_loop(DELAY1, DELAY2);

            gpio_access.turn_on_ledx(LED0_G);
            delay_loop(DELAY1, DELAY2);
         }
}
...
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uart-read-and-write"><a class="header" href="#uart-read-and-write">Uart Read and Write</a></h1>
<p>This Rust program is designed for a Shakti processor and uses the "shakti_riscv_hal" crate. It initializes a UART peripheral, sends two strings over UART, and enters an infinite loop to continuously read characters from the UART. The program is written without relying on the standard library and features inline assembly for delay operations.</p>
<pre><code>#![no_std]
#![no_main]
#![feature(asm)]

use riscv::{asm::delay, delay};
// use cortex_m_rt::entry;
use riscv_rt::entry;
use shakti_riscv_hal::gpio::{GPIOInner, GPIO_OFFSET};
use shakti_riscv_hal::uart::{UartInner, UART_OFFSET};



#[entry]
fn main() -&gt; ! {
    let mut uart = unsafe { UartInner::new(UART_OFFSET) };

    uart.write_uart_string("Hello from shakti \n ");

    uart.write_uart_string("END of the main function");

    loop {
        uart.read_uart_char();
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>![TODO]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributros--authors"><a class="header" href="#contributros--authors">Contributros &amp; Authors</a></h1>
<blockquote>
<ol>
<li><a href="https://github.com/yashwanthsinghm" title="yashwanthsinghm"><strong><code>Yashwanth Singh M</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/strange21" title="strange21"><strong><code>Anand Gedam</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/briandco"><strong><code>Brian</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
<li><a href="https://github.com/briandco"><strong><code>Akshaya</code></strong> <img src="https://img.icons8.com/ios-glyphs/20/11/github.png"/></a></li>
</ol>
</blockquote>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
